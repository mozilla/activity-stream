 /* eslint-disable no-console */
const fs = require("fs");
const {mkdir} = require("shelljs");
const path = require("path");

// Note: this file is generated by webpack from system-addon/content-src/activity-stream-prerender.jsx
const prerender = require("./prerender");

const DEFAULT_LOCALE = "en-US";
const DEFAULT_OPTIONS = {
  addonPath: "../system-addon",
  baseUrl: "resource://activity-stream/"
};

// This locales list is to find any similar locales that we can reuse strings
// instead of falling back to the default, e.g., use bn-BD strings for bn-IN.
// From https://hg.mozilla.org/l10n-central/
// console.log(`const CENTRAL_LOCALES = ${JSON.stringify([...document.querySelectorAll("a.list:not([href*='x-testing']")].map(a => a.textContent.trim()), null, 2)};`)
const CENTRAL_LOCALES = [
  "ach",
  "af",
  "ak",
  "an",
  "ar",
  "as",
  "ast",
  "az",
  "be",
  "bg",
  "bn-BD",
  "bn-IN",
  "br",
  "brx",
  "bs",
  "ca",
  "cak",
  "cs",
  "csb",
  "cy",
  "da",
  "de",
  "dsb",
  "el",
  "en-GB",
  "en-ZA",
  "eo",
  "es-AR",
  "es-CL",
  "es-ES",
  "es-MX",
  "et",
  "eu",
  "fa",
  "ff",
  "fi",
  "fr",
  "fy-NL",
  "ga-IE",
  "gd",
  "gl",
  "gn",
  "gu-IN",
  "he",
  "hi-IN",
  "hr",
  "hsb",
  "hto",
  "hu",
  "hy-AM",
  "ia",
  "id",
  "is",
  "it",
  "ja",
  "ja-JP-mac",
  "ka",
  "kab",
  "kk",
  "km",
  "kn",
  "ko",
  "kok",
  "ks",
  "ku",
  "lg",
  "lij",
  "lo",
  "lt",
  "ltg",
  "lv",
  "mai",
  "mk",
  "ml",
  "mn",
  "mr",
  "ms",
  "my",
  "nb-NO",
  "ne-NP",
  "nl",
  "nn-NO",
  "nr",
  "nso",
  "oc",
  "or",
  "pa-IN",
  "pbb",
  "pl",
  "pt-BR",
  "pt-PT",
  "qvi",
  "rm",
  "ro",
  "ru",
  "rw",
  "sah",
  "sat",
  "si",
  "sk",
  "sl",
  "son",
  "sq",
  "sr",
  "ss",
  "st",
  "sv-SE",
  "sw",
  "ta",
  "ta-LK",
  "te",
  "th",
  "tl",
  "tn",
  "tr",
  "trs",
  "ts",
  "tsz",
  "uk",
  "ur",
  "uz",
  "ve",
  "vi",
  "wo",
  "xh",
  "zam",
  "zh-CN",
  "zh-TW",
  "zu"
];

/**
 * Get the language part of the locale.
 */
function getLanguage(locale) {
  return locale.split("-")[0];
}

/**
 * Get the best strings for a single provided locale using similar locales and
 * DEFAULT_LOCALE as fallbacks.
 */
function getStrings(locale, allStrings) {
  const availableLocales = Object.keys(allStrings);

  const language = getLanguage(locale);
  const similarLocales = availableLocales.filter(other =>
    other !== locale && getLanguage(other) === language);

  // Rank locales from least desired to most desired
  const localeFallbacks = [DEFAULT_LOCALE, ...similarLocales, locale];

  // Get strings from each locale replacing with those from more desired ones
  return Object.assign({}, ...localeFallbacks.map(l => allStrings[l]));
}

/**
 * templateHTML - Generates HTML for activity stream, given some options and
 * prerendered HTML if necessary.
 *
 * @param  {obj} options
 *         {str} options.locale         The locale to render in lang="" attribute
 *         {str} options.direction      The language direction to render in dir="" attribute
 *         {str} options.title          The title for the <title> element
 *         {str} options.baseUrl        The base URL for all local assets
 *         {bool} options.debug         Should we use dev versions of JS libraries?
 * @param  {str} html    The prerendered HTML created with React.renderToString (optional)
 * @return {str}         An HTML document as a string
 */
function templateHTML(options, html) {
  const isPrerendered = !!html;
  const debugString = options.debug ? "-dev" : "";
  const scripts = [
    "chrome://browser/content/contentSearchUI.js",
    `${options.baseUrl}vendor/react${debugString}.js`,
    `${options.baseUrl}vendor/react-dom${debugString}.js`,
    `${options.baseUrl}vendor/react-intl.js`,
    `${options.baseUrl}vendor/redux.js`,
    `${options.baseUrl}vendor/react-redux.js`,
    `${options.baseUrl}data/content/activity-stream.bundle.js`
  ];
  if (isPrerendered) {
    scripts.unshift(`${options.baseUrl}data/content/activity-stream-initial-state.js`);
  }
  return `<!doctype html>
<html lang="${options.locale}" dir="${options.direction}">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Security-Policy-Report-Only" content="script-src 'unsafe-inline'; img-src http: https: data: blob:; style-src 'unsafe-inline'; child-src 'none'; object-src 'none'; report-uri https://tiles.services.mozilla.com/v4/links/activity-stream/csp">
    <title>${options.title}</title>
    <link rel="icon" type="image/png" id="favicon" href="chrome://branding/content/icon32.png"/>
    <link rel="stylesheet" href="chrome://browser/content/contentSearchUI.css" />
    <link rel="stylesheet" href="${options.baseUrl}data/content/activity-stream.css" />
  </head>
  <body class="activity-stream">
    <div id="root">${isPrerendered ? html : ""}</div>
    <div id="snippets-container">
      <div id="snippets"></div>
    </div>
    <script>
// Don't directly load the following scripts as part of html to let the page
// finish loading to render the content sooner.
for (const src of ${JSON.stringify(scripts, null, 2)}) {
  // These dynamically inserted scripts by default are async, but we need them
  // to load in the desired order (i.e., bundle last).
  const script = document.body.appendChild(document.createElement("script"));
  script.async = false;
  script.src = src;
}
    </script>
  </body>
</html>
`;
}

/**
 * templateJs - Generates a js file that passes the initial state of the prerendered
 * DOM to the React version. This is necessary to ensure the checksum matches when
 * React mounts so that it can attach to the prerendered elements instead of blowing
 * them away.
 *
 * Note that this may no longer be necessary in React 16 and we should review whether
 * it is still necessary.
 *
 * @param  {obj} state  The
 * @return {str}        The js file as a string
 */
function templateJs(state) {
  return `// Note - this is a generated file.
  window.gActivityStreamPrerenderedState = ${JSON.stringify(state, null, 2)};
`;
}

/**
 * writeFiles - Writes to the desired files the result of a template given
 * various prerendered data and options.
 *
 * @param {string} name          Something to identify in the console
 * @param {string} destPath      Path to write the files to
 * @param {Map}    filesMap      Mapping of a string file name to templater
 * @param {Object} prerenderData Contains the html and state
 * @param {Object} options       Various options for the templater
 */
function writeFiles(name, destPath, filesMap, {html, state}, options) {
  for (const [file, templater] of filesMap) {
    fs.writeFileSync(path.join(destPath, file), templater({html, options, state}));
  }
  console.log("\x1b[32m", `✓ ${name}`, "\x1b[0m");
}

const DEBUG_FILES = new Map([
  ["activity-stream-debug.html", ({options}) => templateHTML(options)],
  ["activity-stream-prerendered-debug.html", ({html, options}) => templateHTML(options, html)]
]);

const LOCALIZED_FILES = new Map([
  ["activity-stream-initial-state.js", ({state}) => templateJs(state)],
  ["activity-stream-prerendered.html", ({html, options}) => templateHTML(options, html)],
  ["activity-stream.html", ({options}) => templateHTML(options)]
]);

/**
 * main - Parses command line arguments, generates html and js with templates,
 *        and writes files to their specified locations.
 */
function main() { // eslint-disable-line max-statements
  // This code parses command line arguments passed to this script.
  // Note: process.argv.slice(2) is necessary because the first two items in
  // process.argv are paths
  const args = require("minimist")(process.argv.slice(2), {
    alias: {
      addonPath: "a",
      baseUrl: "b"
    }
  });

  const baseOptions = Object.assign({debug: false}, DEFAULT_OPTIONS, args || {});
  const addonPath = path.resolve(__dirname, baseOptions.addonPath);
  const allStrings = require(`${baseOptions.addonPath}/data/locales.json`);
  const extraLocales = Object.keys(allStrings).filter(locale =>
    locale !== DEFAULT_LOCALE && !CENTRAL_LOCALES.includes(locale));

  const prerenderedPath = path.join(addonPath, "prerendered");
  console.log(`Writing prerendered files to individual directories under ${prerenderedPath}:`);

  // Save default locale's strings to compare against other locales' strings
  let defaultStrings;
  const hasOnlyDefaultStrings = strings => defaultStrings &&
    !Object.keys(strings).some(key => strings[key] !== defaultStrings[key]);

  // Process the default locale first then all the ones from mozilla-central
  const localizedLocales = [];
  const skippedLocales = [];
  for (const locale of [DEFAULT_LOCALE, ...CENTRAL_LOCALES, ...extraLocales]) {
    const strings = getStrings(locale, allStrings);
    if (hasOnlyDefaultStrings(strings)) {
      skippedLocales.push(locale);
      continue;
    }

    const prerenderData  = prerender(locale, strings);
    const {App} = prerenderData.state;
    const options = Object.assign({}, baseOptions, {
      direction: App.textDirection,
      locale,
      title: App.strings.newtab_page_title
    });

    // Put locale-specific files in their own directory
    const localePath = path.join(prerenderedPath, locale);
    mkdir("-p", localePath);
    writeFiles(locale, localePath, LOCALIZED_FILES, prerenderData, options);

    // Only write debug files for the default locale
    if (locale === DEFAULT_LOCALE) {
      writeFiles(`${locale} (debug)`, localePath, DEBUG_FILES, prerenderData,
        Object.assign({}, options, {debug: true}));

      // Save the default strings to compare against other locales' strings
      defaultStrings = strings;
    }

    localizedLocales.push(locale);
  }

  if (skippedLocales.length) {
    console.log("\x1b[33m", `Skipped the following locales because they use the same strings as ${DEFAULT_LOCALE}: ${skippedLocales.join(", ")}`, "\x1b[0m");
  }
  if (extraLocales.length) {
    console.log("\x1b[31m", `✗ These locales were not in CENTRAL_LOCALES, but probably should be: ${extraLocales.join(", ")}`, "\x1b[0m");
  }

  // Prepare lines that we'll need for updating jar.mn
  const defineLines = [];
  const ifLines = [];
  const elseLines = ["#else"];
  for (const locale of localizedLocales) {
    let targetLines;
    if (locale === DEFAULT_LOCALE) {
      targetLines = elseLines;
    } else {
      // Preprocessor can't do "-" in conditions (SYNTAX_ERR) so indirection!
      const condLocale = locale.replace(/-/g, "_");
      if (condLocale !== locale) {
        defineLines.push(`#define ${condLocale} ${locale}`);
      }
      ifLines.push(`#${ifLines.length ? "elif" : "if"} AB_CD == ${condLocale}`);
      targetLines = ifLines;
    }
    for (const file of LOCALIZED_FILES.keys()) {
      targetLines.push(`  content/data/content/${file} (./prerendered/${locale}/${file})`);
    }
  }

  // Replace existing render-generated lines in jar.mn
  const scriptName = path.basename(__filename);
  const jarFile = path.join(addonPath, "jar.mn");
  const jarLines = fs.readFileSync(jarFile, "utf8").split("\n");
  const startLine = jarLines.findIndex(line => line.includes(scriptName));
  const endLine = jarLines.indexOf("#endif", startLine);
  jarLines.splice(startLine, endLine - startLine + 1, ...[
    `# These defines and ifs below are generated by https://github.com/mozilla/activity-stream/blob/master/bin/${scriptName}`,
    ...defineLines,
    ...ifLines,
    ...elseLines,
    "#endif"
  ]);
  fs.writeFileSync(jarFile, jarLines.join("\n"));
  console.log(`Updated ${jarFile} with current #defines and #ifs`);
}

main();
